#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK
import os
os.environ['TERM'] = 'xterm' # removes warning on non-tty commands

import argparse
#import argcomplete
#from argcomplete.completers import ChoicesCompleter
from configparser import ConfigParser, ExtendedInterpolation
import docker
import random
import string
import sys

prog = 'dockersh'
version = prog + " v1.0"
config_file = "/etc/dockersh.ini"

user = os.environ['USER']
host = os.uname()[1]

cli = docker.APIClient()

def containers(image_filter='', container_filter='', sort_by='Created', all=True):
    cs = cli.containers(all=all, filters={'label': "user="+user})
    cs.sort(key=lambda c: c[sort_by])
    cs = [c for c in cs if str(c['Image']+':latest').startswith(image_filter)]
    cs = [c for c in cs if c['Names'][0][1:].startswith(container_filter)]
    return cs

def random_string(length):
        def random_char():
            return random.choice(string.ascii_uppercase + string.digits)
        return ''.join(random_char() for _ in range(length))

def strip(s, suffix=''):
    for c in ['/', ':', '.', ' ']: #QUESTION does this suffice?
        s = s.replace(c, '')
    if s.endswith(suffix):
        s = s[:len(s)-len(suffix)]
    return s

def pull(image):
    if not image in image_names:
        s = image.split(':')
        if len(s) > 1:
            cli.pull(s[0], s[1])
        else:
            cli.pull(s[0])

def image_split(s):
    sp = s.split(':')
    if len(sp) == 1:
        return sp[0], 'latest'
    else:
        return sp[0], sp[1]

def selection_menu(choices):
    if len(choices) == 1:
        return 0
    print("There are multiple matching containers running:")
    for j, c in enumerate(choices):
        print("[" + str(j+1) + "]\t" + c)
    inp = input("select [1]: ")
    if inp == "":
        i = 0
    else:
        i = int(inp) - 1
        assert(0 <= i < len(choices))
    return i

#if __name__ == "__main__":
def parse_args():



    parser = argparse.ArgumentParser(prog=prog)
    parser.add_argument('--version',
                        action='version',
                        version=version)
    parser.add_argument('-i', '--image',
                        dest='image',
                        help="base image to be used",
                        default="") #.completer = ChoicesCompleter(tuple(images))
    parser.add_argument('-n', '--name',
                        dest='name',
                        help="container name",
                        default="") #.completer = ChoicesCompleter(tuple(containers))
    parser.add_argument('-t', '--temporary',
                        dest='temp',
                        action='store_true',
                        help="execute in temporary container",
                        default=False)
    parser.add_argument('-c', '--command',
                        dest='cmd',
                        help="pass command to bash in container",
                        default="")
    parser.add_argument('--shell',
                        dest='shell',
                        help="shell to start inside the container",
                        default=ini['shell'])
    parser.add_argument('--home',
                        dest='home',
                        help="user home directory",
                        default=ini['homedir'])
    #argcomplete.autocomplete(parser) #TODO make autocompletion work
    args = parser.parse_args()

    args.suffix = ini['suffix']
    args.greeting = ini['greeting']
    args.ini = ini
    return args


# load ini
cfg = ConfigParser(os.environ, interpolation=ExtendedInterpolation())
cfg.read(config_file)

admin_cmd = "admin"
if cfg.has_section("ADMINS") and "command" in cfg["ADMINS"]["command"]:
    admin_cmd = cfg["ADMINS"]["command"]
ini = cfg[user] if cfg.has_section(user) else cfg['DEFAULT']

#if __name__ == "__main__":
args = parse_args()

host_config = cli.create_host_config(binds=[args.home + ':/home/' + user],
                                     restart_policy={'Name' : 'unless-stopped'})

if args.cmd == admin_cmd:
    print("Trying to login into host: "+user)
    os.system("sudo -S su "+user+"; cd /home/"+user)
    sys.exit(0)


if args.cmd:
    cmd_splits = args.cmd.split(" ",1)
    if (os.path.basename(cmd_splits[0])+cmd_splits[1]).startswith(("scp -p","rsync --server","sftp-server")):
        os.system("rssh -c \""+args.cmd+"\"")
        sys.exit(0)
name_passed  = (args.name  != "")
image_passed = (args.image != "")

if args.temp:
    if not image_passed:
        args.image = args.ini['image']
    args.image_base, args.image_tag = image_split(args.image)
    args.image = args.image_base + ':' + args.image_tag
    args.name = strip(args.image) + '_tmp' + random_string(4)
else:
    if name_passed:
        args.name = strip(args.name, args.suffix)

    filtered_con = containers(image_filter=args.image, container_filter=args.name)

    if len(filtered_con) > 0:
        con_names = [c['Names'][0][1:] for c in filtered_con]
        i = selection_menu(con_names)
        args.name = strip(con_names[i], args.suffix)
    else:
        if not image_passed:
            args.image = args.ini['image']
        args.image_base, args.image_tag = image_split(args.image)
        args.image = args.image_base + ':' + args.image_tag

        if not name_passed:
            args.name = strip(args.image)

        if len(containers(container_filter=args.name)) != 0:
            print("WARNING: container name already exists (ignoring --image)")

args.full_name = args.name + args.suffix

if len(containers(container_filter=args.name)) == 0:
    #cli.pull(args.image)
    cli.create_container(args.image,
                         stdin_open=True,
                         tty=True,
                         name=args.full_name,
                         command=args.shell,
                         hostname=args.name,
                         labels={'group': prog, 'user': user},
                         volumes=['/home/'+user],
                         working_dir='/home/'+user,
                         host_config=host_config)

cli.start(args.full_name)
print(args.greeting)
cmd = args.cmd if args.cmd else args.shell
#cli.attach(cfg.name, stream=True) #BUG https://github.com/docker/docker-py/issues/390
docker_arg = "" if not sys.stdout.isatty() else "-it"
os.system('docker exec ' + docker_arg +' '+ args.full_name + ' ' + cmd) #HACK

if args.temp:
    cli.remove_container(args.full_name, v=True, force=True)

cli.close()
