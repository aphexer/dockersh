#!/usr/bin/env python3
# PYTHON_ARGCOMPLETE_OK

import argparse
import argcomplete
from argcomplete.completers import ChoicesCompleter
from configparser import ConfigParser, ExtendedInterpolation
import docker
import random
import string
import os
import sys

prog = 'dockersh'
version = prog + " v1.0"
config_file = "dockersh.ini"

user = os.environ['USER']
home = os.environ['HOME']
host = os.uname()[1]

cli = docker.APIClient()

def containers(image_filter='', sort_by='Created', all=True):
    cs = cli.containers(all=all, filters={'label': "user="+user})
    cs.sort(key=lambda c: c[sort_by])
    cs = [c for c in cs if c['Image'].startswith(image_filter)]
    return cs

def images(image_filter='', sort_by='Created'):
    empty = '<none>:<none>'
    imgs = cli.images()
    imgs.sort(key=lambda i: i[sort_by])
    imgs = [i for i in imgs if i['RepoTags'][0].startswith(image_filter) and i['RepoTags'][0] != empty]
    return imgs

def random_string(length):
        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(length))

def strip(s, suffix=''):
    if s.endswith(suffix):
        s = s[:len(s)-len(suffix)]
    for c in ['/', ':', '.']: #QUESTION does this suffice?
        s = s.replace(c, '')
    return s

def pull(image):
    if not image in image_names:
        s = image.split(':')
        if len(s) > 1:
            cli.pull(s[0], s[1])
        else:
            cli.pull(s[0])

def image_split(s):
    sp = s.split(':')
    if len(sp) == 1:
        return sp[0], 'latest'
    else:
        return sp[0], sp[1]

def image_valid(s):
    return True #TODO implement

def load_ini():
    cfg = ConfigParser(os.environ, interpolation=ExtendedInterpolation())
    cfg.read(config_file)

    if cfg.has_section(user):
        return cfg[user]
    else:
        return cfg['DEFAULT']

def selection_menu(choices):
    print("There are multiple containers assigned to your account:")
    for j, c in enumerate(choices):
        print("[" + str(j+1) + "]\t" + c)
    inp = input("select [1]: ")
    if inp == "":
        i = 0
    else:
        i = int(inp) - 1
        assert(0 <= i < len(choices))
    return i

def params():
    ini = load_ini()

    parser = argparse.ArgumentParser(prog=prog)
    parser.add_argument('--version', action='version', version=version)
    parser.add_argument('-i', '--image', dest='image', help="base image to be used").completer = ChoicesCompleter(tuple(images))
    parser.add_argument('-n', '--name', dest='name', help="container name").completer = ChoicesCompleter(tuple(containers))
    parser.add_argument('-t', '--temporary', dest='temp', action='store_true', help="execute in temporary container", default=False)
    parser.add_argument('--shell', dest='shell', help="shell to start inside the container", default=ini['shell'])
    parser.add_argument('--home', dest='home', help="user home directory", default=ini['home'])
    argcomplete.autocomplete(parser) #TODO make autocompletion work
    args = parser.parse_args()

    args.suffix = ini['container_suffix']
    args.greeting = ini['greeting']

    name_passed  = (args.name  != None)
    image_passed = (args.image != None)

    #TODO implement logic for argument decision tree

    cfg.full_name = cfg.name + cfg.suffix

def run():
    cfg = params()

    host_config = cli.create_host_config(binds=[cfg.home + ':/home/' + user],
                                         restart_policy={'Name' : 'unless-stopped'})

    if not cfg.full_name in containers():
        pull(cfg.image)
        cli.create_container(cfg.image,
                             stdin_open=True,
                             tty=True,
                             name=cfg.full_name,
                             command=cfg.shell,
                             hostname=cfg.name,
                             labels={'group': prog, 'user': user},
                             volumes=['/home/'+user],
                             working_dir='/home/'+user,
                             host_config=host_config)

    cli.start(cfg.full_name)
    print(cfg.greeting)
    #cli.attach(cfg.name, stream=True) #BUG https://github.com/docker/docker-py/issues/390
    os.system('docker exec -it ' + cfg.full_name + ' ' + cfg.shell) #HACK

    if cfg.temp:
        cli.remove_container(cfg.full_name, v=True, force=True)

    cli.close()

if __name__ == "__main__":
    run()
